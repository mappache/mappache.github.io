<!--<html>
<head>
  <title>My first Three.js app</title>
  <style>
      canvas { width: 100%; height: 100% }
      body {overflow: hidden}
  </style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src='js/STLLoader.js'></script>
<script src='js/OBJLoader.js'></script>
<script>
    var logo;
  var scene = new THREE.Scene();
  var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);
  var renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  var geometry = new THREE.BoxGeometry(350, 350, 350, 10, 10, 10);

  var logo_cap_texture =
          THREE.ImageUtils.loadTexture("images/mappache2.png");
 // var material = new THREE.MeshLambertMaterial({map:logo_cap_texture});

  var loader = new THREE.TextureLoader();
  loader.load('images/mappache2.png', function ( texture ) {
      var geometry = new THREE.CylinderGeometry(100,100,10,500);
      var material = new THREE.MeshBasicMaterial({map: texture, overdraw: 0.5});
      logo = new THREE.Mesh(geometry, material);
      scene.add(logo);
  });

  //var material = new THREE.MeshBasicMaterial({color: 0xfffff, wireframe: true});
  //var cube = new THREE.Mesh(geometry, material);
  //scene.add(cube);
  camera.position.z = 1000;
  controls = new THREE.OrbitControls(camera, renderer.domElement);

  function render() {
    requestAnimationFrame(render);
    logo.rotation.x += 0.01;
    logo.rotation.y += 0.01;
    renderer.render(scene, camera);
  };
  render();
</script>
</body>
</html> -->
<!DOCTYPE html>
<html>
<!-- include three.js -->
<script src='js/three.min.js'></script>
<script src='js/OrbitControls.js'></script>
<script src='js/STLLoader.js'></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>


<head>
    <meta charset="UTF-8">
    <title>MappacheCo. Test</title>
    <style>
        body {
            background: #000000;
            overflow: hidden;
        }
        h1 {
            color: darkcyan;
        }

        #context {
            width: 400px;
            height: 300px;
            margin: auto;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
    </style>
</head>

<body>
<h1>
    MappacheCo. Testing Environment
</h1>

<script>
    var logo;
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);
    var renderer = new THREE.WebGLRenderer({antialias : true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var loader = new THREE.TextureLoader();
    loader.load('images/mappache2.png', function ( texture ) {
        var geometry = new THREE.CylinderGeometry(300,300,10,500);
        var material = new THREE.MeshBasicMaterial({map: texture, overdraw: 0.5});
        logo = new THREE.Mesh(geometry, material);
        scene.add(logo);
    });

    camera.position.z = 1000;
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    //function render() {
    //    requestAnimationFrame(render);
    //    logo.rotation.x += 0.01;
    //    logo.rotation.y += 0.01;
    //    renderer.render(scene, camera);
    //};
    //render();
    //abajo viene lo de interaccion. Si se borra tod√≥ lo de abajo, des-comentar la function render de arriba.
    ///////////////////////////////////////////////////////////////////////////////////////////////////////
    var isTouching = false;
    var previousHandPosition = {
        x: 0,
        y: 0
    };
    $(renderer.domElement).on('touchstart', function(e) {
        isTouching = true;
    })
            .on('touchmove', function(e) {
                //console.log(e);
                var deltaMove = {
                    x: e.offsetX-previousMousePosition.x,
                    y: e.offsetY-previousMousePosition.y
                };

                if(isTouching) {

                    var deltaRotationQuaternion = new THREE.Quaternion()
                            .setFromEuler(new THREE.Euler(
                                    toRadians(deltaMove.y * 1),
                                    toRadians(deltaMove.x * 1),
                                    0,
                                    'XYZ'
                            ));

                    logo.quaternion.multiplyQuaternions(deltaRotationQuaternion, logo.quaternion);
                }

                previousHandPosition = {
                    x: e.offsetX,
                    y: e.offsetY
                };
            });
    /* */


    $(document).on('touchend', function(e) {
        isTouching = false;
    });

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

    // shim layer with setTimeout fallback
    window.requestAnimFrame = (function(){
        return  window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function(callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
    })();

    var lastFrameTime = new Date().getTime() / 1000;
    var totalGameTime = 0;
    function update(dt, t) {
        //console.log(dt, t);

        //camera.position.z += 1 * dt;
        //logo.rotation.x += 0.01 * dt;
        //logo.rotation.y += 0.01 * dt;

        setTimeout(function() {
            var currTime = new Date().getTime() / 1000;
            var dt = currTime - (lastFrameTime || currTime);
            totalGameTime += dt;

            update(dt, totalGameTime);

            lastFrameTime = currTime;
        }, 0);
    }



    function render() {
        requestAnimFrame(render);
        logo.rotation.x += 0.01;
        logo.rotation.y += 0.01;
        renderer.render(scene, camera);
    }

    render();
    update(0, totalGameTime);

    function toRadians(angle) {
        return angle * (Math.PI / 180);
    }

    function toDegrees(angle) {
        return angle * (180 / Math.PI);
    }

</script>
</body>
</html>
