<!DOCTYPE html>
<html>
<!-- include three.js -->
<script src='js/three.min.js'></script>
<script src='js/OrbitControls.js'></script>
<script src='js/STLLoader.js'></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>

<head>
    <meta charset="UTF-8">
    <title>MappacheCo. Test</title>
   <style>
        body {
            background: #000000;
            overflow: hidden;
        }
        h1 {
           color: darkcyan;
        }

        #context {
            width: 400px;
            height: 300px;
            margin: auto;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
    </style>
</head>

<body>
    <h1>
        MappacheCo. Testing Environment
    </h1>

<script>
    var logo;
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 10000);
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var loader = new THREE.TextureLoader();
    loader.load('images/mappache2.png', function ( texture ) {
        var geometry = new THREE.CylinderGeometry(300,300,10,500);
        var material = new THREE.MeshBasicMaterial({map: texture, overdraw: 0.5});
        logo = new THREE.Mesh(geometry, material);
        scene.add(logo);
    });

    camera.position.z = 1000;
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    //function render() {
    //    requestAnimationFrame(render);
    //    logo.rotation.x += 0.01;
    //    logo.rotation.y += 0.01;
    //    renderer.render(scene, camera);
    //};
    //render();

///////////////////////////////////////////////////////////////////////////////////////////////////////
    /////////////// PARTE TOUCH //////////////////////////////////
    //////////////////////////////////////////////////

    var isTouching = false;
    var previousHandPosition = {
        x: 0,
        y: 0
    };
    $(renderer.domElement).on('touchstart', function(e) {
        isTouching = true;
    })
            .on('touchmove', function(e) {
                //console.log(e);
                var deltaMove = {
                    x: e.offsetX-previousMousePosition.x,
                    y: e.offsetY-previousMousePosition.y
                };

                if(isTouching) {

                    var deltaRotationQuaternion = new THREE.Quaternion()
                            .setFromEuler(new THREE.Euler(
                                    toRadians(deltaMove.y * 1),
                                    toRadians(deltaMove.x * 1),
                                    0,
                                    'XYZ'
                            ));

                    logo.quaternion.multiplyQuaternions(deltaRotationQuaternion, logo.quaternion);
                }

                previousHandPosition = {
                    x: e.offsetX,
                    y: e.offsetY
                };
            });
    /* */


    $(document).on('touchend', function(e) {
        isTouching = false;
    });



/////////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////
    ////////////////////////////////////////////////////////////////
    /////////// PARTE DE WEB - MOUSE DRAGGING //////////////////////////////////////////////
    ////////////////////////////////////////////////
    var isDragging = false;
    var previousMousePosition = {
        x: 0,
        y: 0
    };
    $(renderer.domElement).on('mousedown', function(e) {
        isDragging = true;
    })
            .on('mousemove', function(e) {
                //console.log(e);
                var deltaMove = {
                    x: e.offsetX-previousMousePosition.x,
                    y: e.offsetY-previousMousePosition.y
                };

                if(isDragging) {

                    var deltaRotationQuaternion = new THREE.Quaternion()
                            .setFromEuler(new THREE.Euler(
                                    toRadians(deltaMove.y * 1),
                                    toRadians(deltaMove.x * 1),
                                    0,
                                    'XYZ'
                            ));

                    logo.quaternion.multiplyQuaternions(deltaRotationQuaternion, logo.quaternion);
                }

                previousMousePosition = {
                    x: e.offsetX,
                    y: e.offsetY
                };
            });
    /* */


    $(document).on('mouseup', function(e) {
        isDragging = false;
    });

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    var c=1;
    var cc=3;
    var ccc=3;
    $(document).on('mousewheel', function (e) {
        console.log(e.deltaY);
        if(e.deltaY>0){
            c=c*0.95
            cc=cc*0.95;
            ccc=ccc*0.95
            camera.position.set(c, cc, ccc);
        }else{
            c=c*1.05
            cc=cc*1.05;
            ccc=ccc*1.05
            camera.position.set(c, cc, ccc);}
    });
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

    // shim layer with setTimeout fallback
    window.requestAnimFrame = (function(){
        return  window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function(callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
    })();

    var lastFrameTime = new Date().getTime() / 1000;
    var totalGameTime = 0;
    function update(dt, t) {
        //console.log(dt, t);

        //camera.position.z += 1 * dt;
        //logo.rotation.x += 0.01 * dt;
        //logo.rotation.y += 0.01 * dt;

        setTimeout(function() {
            var currTime = new Date().getTime() / 1000;
            var dt = currTime - (lastFrameTime || currTime);
            totalGameTime += dt;

            update(dt, totalGameTime);

            lastFrameTime = currTime;
        }, 0);
    }


    function render() {
        requestAnimFrame(render);
        logo.rotation.x += 0.01;
        logo.rotation.y += 0.01;
        renderer.render(scene, camera);




    }

    render();
    update(0, totalGameTime);

    function toRadians(angle) {
        return angle * (Math.PI / 180);
    }

    function toDegrees(angle) {
        return angle * (180 / Math.PI);
    }

</script>
</body>
</html>